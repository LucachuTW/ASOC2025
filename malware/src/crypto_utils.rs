//! Utilidades criptográficas para proteger y recuperar configuraciones de prueba.

use aes::Aes256;
use cbc::{Decryptor, Encryptor};
use cipher::{block_padding::Pkcs7, BlockDecryptMut, BlockEncryptMut, KeyIvInit};
use obfstr::obfstr;
use sha2::{Digest, Sha256};

use crate::telemetry::SystemSnapshot;

type Aes256CbcDec = Decryptor<Aes256>;

#[allow(dead_code)]
pub fn bootstrap_crypto_context(snapshot: &SystemSnapshot) {
    // Deriva clave a partir de la telemetría del sistema.
    match derive_key_from_telemetry(snapshot) {
        Some(key) => {
            println!("[crypto] Clave derivada (SHA-256): {}", hex::encode(&key));
            // Ejemplo de configuración cifrada (plaintext: "demo_config_value").
            let ciphertext = build_demo_ciphertext(&key);
            match decrypt_protected_config(&ciphertext, &key) {
                Some(plain) => println!(
                    "[crypto] Descifrado de demo exitoso: {}",
                    String::from_utf8_lossy(&plain)
                ),
                None => println!("[crypto] Fallo al descifrar configuración protegida."),
            }
        }
        None => println!("[crypto] No se pudo derivar clave desde la telemetría."),
    };
}

/// Descifra datos AES-256-CBC con padding PKCS#7.
#[allow(dead_code)]
pub fn decrypt_protected_config(ciphertext: &[u8], key: &[u8]) -> Option<Vec<u8>> {
    if key.len() != 32 || ciphertext.len() < 16 {
        return None;
    }

    let (iv, body) = ciphertext.split_at(16);
    let mut buffer = body.to_vec();

    // Aquí se usa AES-256 en modo CBC con IV fijo extraído del ciphertext.
    Aes256CbcDec::new(key.into(), iv.into())
        .decrypt_padded_mut::<Pkcs7>(&mut buffer)
        .ok()
        .map(|p| p.to_vec())
}

/// Deriva una clave AES de 256 bits basándose en telemetría de sistema.
#[allow(dead_code)]
pub fn derive_key_from_telemetry(snapshot: &SystemSnapshot) -> Option<Vec<u8>> {
    // Material de clave: RAM total, CPUs lógicas y nombre de host.
    let material = format!(
        "{}:{}:{}:{}",
        snapshot.total_memory, snapshot.cpu_logical, snapshot.host_name, snapshot.os_name
    );

    // Hash SHA-256 para obtener 32 bytes.
    let mut hasher = Sha256::new();
    hasher.update(material.as_bytes());
    let digest = hasher.finalize();
    Some(digest.to_vec())
}

/// Construye un ciphertext de demostración usando la misma clave derivada.
fn build_demo_ciphertext(key: &[u8]) -> Vec<u8> {
    // IV fijo de demostración; en escenarios reales debe ser aleatorio.
    let iv = [0u8; 16];
    let plaintext = obfstr!("demo_config_value").as_bytes().to_vec();

    type Aes256CbcEnc = Encryptor<Aes256>;

    // `encrypt_padded_mut` rellena PKCS#7 internamente; se necesita espacio extra.
    let mut buffer = plaintext.clone();
    let msg_len = buffer.len();
    buffer.resize(msg_len + 16, 0); // reserva un bloque adicional para padding

    let enc_len = Aes256CbcEnc::new(key.into(), (&iv).into())
        .encrypt_padded_mut::<Pkcs7>(&mut buffer, msg_len)
        .expect("padding encryption")
        .len();
    buffer.truncate(enc_len);
    let ciphertext_body = buffer;

    // Se antepone el IV para que el descifrado pueda extraerlo fácilmente.
    [iv.to_vec(), ciphertext_body].concat()
}
