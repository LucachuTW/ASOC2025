//! Encapsula experimentos de codificación/esteganografía para buffers de datos simulados.

#[allow(dead_code)]
pub fn encode_demo_payload() {
    use image::{ImageBuffer, Rgb};

    let payload = b"simulated_config_block_for_lab";

    // Construye una imagen de base determinística para no depender de archivos externos.
    let base_dir = "artifacts";
    let input_path = format!("{}/demo_input.png", base_dir);
    let output_path = format!("{}/demo_encoded.png", base_dir);
    let _ = std::fs::create_dir_all(base_dir);

    let width: u32 = 64;
    let height: u32 = 64;
    let base_img: ImageBuffer<Rgb<u8>, Vec<u8>> = ImageBuffer::from_fn(width, height, |x, y| {
        Rgb([
            (x as u8).wrapping_mul(3),
            (y as u8).wrapping_mul(5),
            (x as u8).wrapping_add(y as u8),
        ])
    });
    if let Err(err) = base_img.save(&input_path) {
        eprintln!("[encoder] No se pudo guardar imagen base: {err}");
        return;
    }

    match lsb_embed(&input_path, payload) {
        Some((raw, w, h)) => {
            if let Some(mutated) = image::RgbImage::from_raw(w, h, raw) {
                if let Err(err) = mutated.save(&output_path) {
                    eprintln!("[encoder] Fallo al guardar imagen codificada: {err}");
                } else {
                    println!("[encoder] Imagen codificada escrita en {output_path}");
                }
            } else {
                eprintln!("[encoder] No se pudo reconstruir la imagen codificada en memoria.");
            }
        }
        None => eprintln!("[encoder] Capacidad insuficiente o error durante la inserción LSB."),
    }
}

#[allow(dead_code)]
pub fn lsb_embed(image_path: &str, payload: &[u8]) -> Option<(Vec<u8>, u32, u32)> {
    // Leer la imagen de origen y convertirla a formato mutable RGB.
    let mut img = image::open(image_path).ok()?.to_rgb8();
    let (width, height) = img.dimensions();

    // Capacidad en bits: cada canal RGB aporta 1 bit útil.
    let capacity_bits = (width as usize) * (height as usize) * 3;
    let payload_bits = payload.len() * 8;
    let length_header_bits = 32; // prefijo con la longitud del payload
    let total_needed_bits = payload_bits + length_header_bits;

    if total_needed_bits > capacity_bits {
        return None;
    }

    let mut bits = Vec::with_capacity(total_needed_bits);

    // Prefijo: longitud del payload en big-endian para reconstrucción futura.
    for byte in (payload.len() as u32).to_be_bytes() {
        for bit_index in (0..8).rev() {
            bits.push((byte >> bit_index) & 1);
        }
    }

    for byte in payload {
        for bit_index in (0..8).rev() {
            bits.push((byte >> bit_index) & 1);
        }
    }

    let mut bit_iter = bits.into_iter();
    for channel in img.pixels_mut().flat_map(|p| p.0.iter_mut()) {
        if let Some(bit) = bit_iter.next() {
            *channel = (*channel & 0xFE) | bit;
        } else {
            break;
        }
    }

    Some((img.into_raw(), width, height))
}
