//! Investigación de interoperabilidad con procesos externos usando la API de Windows.

#[allow(dead_code)]
pub fn simulate_process_interop() {
    #[cfg(target_os = "windows")]
    {
        if let Err(err) = simulate_process_interop_windows() {
            eprintln!("[process] Error en demo de interoperabilidad: {:?}", err);
        }
    }

    #[cfg(not(target_os = "windows"))]
    {
        println!("[process] Demo de interoperabilidad requiere Windows; omitiendo en este entorno.");
    }
}

#[cfg(target_os = "windows")]
fn simulate_process_interop_windows() -> windows::core::Result<()> {
    use obfstr::obfstr;
    use std::ffi::OsStr;
    use std::mem::{size_of, zeroed};
    use std::os::windows::ffi::OsStrExt;
    use windows::core::{PCWSTR, PWSTR};
    use windows::Win32::Foundation::{CloseHandle, Error};
    use windows::Win32::System::Diagnostics::Debug::WriteProcessMemory;
    use windows::Win32::System::Memory::{VirtualAllocEx, MEM_COMMIT, MEM_RESERVE, PAGE_READWRITE};
    use windows::Win32::System::Threading::{
        CreateProcessW, ResumeThread, PROCESS_INFORMATION, STARTUPINFOW, CREATE_SUSPENDED,
    };

    // Preparar cadena de comandos para el proceso hijo.
    let child_path = obfstr!("C:\\Windows\\System32\\notepad.exe");
    let mut command: Vec<u16> = OsStr::new(&child_path)
        .encode_utf16()
        .chain(std::iter::once(0))
        .collect();

    // Estructuras STARTUPINFOW / PROCESS_INFORMATION inicializadas a cero.
    let mut startup: STARTUPINFOW = unsafe { zeroed() };
    startup.cb = size_of::<STARTUPINFOW>() as u32;
    let mut proc_info: PROCESS_INFORMATION = unsafe { zeroed() };

    // Crear proceso en estado suspendido para permitir inspección/modificación previa.
    let created = unsafe {
        CreateProcessW(
            PCWSTR::null(),            // lpApplicationName
            PWSTR(command.as_mut_ptr()),
            None,                      // lpProcessAttributes
            None,                      // lpThreadAttributes
            false,                     // bInheritHandles
            CREATE_SUSPENDED,          // dwCreationFlags
            None,                      // lpEnvironment
            PCWSTR::null(),            // lpCurrentDirectory
            &mut startup,              // lpStartupInfo
            &mut proc_info,            // lpProcessInformation
        )
    };

    if !created.as_bool() {
        return Err(Error::from_win32());
    }
    println!("[process] Proceso suspendido lanzado (PID: {}).", proc_info.dwProcessId);

    // Reservar memoria remota y escribir un buffer de prueba.
    let payload = b"EDR-friendly lab payload";
    let remote_allocation = unsafe {
        VirtualAllocEx(
            proc_info.hProcess,
            None,
            payload.len(),
            MEM_COMMIT | MEM_RESERVE,
            PAGE_READWRITE,
        )
    };

    if remote_allocation.is_null() {
        unsafe {
            CloseHandle(proc_info.hThread);
            CloseHandle(proc_info.hProcess);
        }
        return Err(Error::from_win32());
    }
    println!(
        "[process] Memoria remota reservada en {:p} ({} bytes).",
        remote_allocation,
        payload.len()
    );

    let mut bytes_written: usize = 0;
    let write_ok = unsafe {
        WriteProcessMemory(
            proc_info.hProcess,
            remote_allocation,
            payload.as_ptr() as *const _,
            payload.len(),
            Some(&mut bytes_written),
        )
    };

    if !write_ok.as_bool() || bytes_written != payload.len() {
        unsafe {
            CloseHandle(proc_info.hThread);
            CloseHandle(proc_info.hProcess);
        }
        return Err(Error::from_win32());
    }
    println!(
        "[process] Buffer de prueba escrito con WriteProcessMemory ({} bytes).",
        bytes_written
    );

    // Reanudar el hilo principal después de la manipulación.
    let resume_code = unsafe { ResumeThread(proc_info.hThread) };
    println!("[process] Hilo principal reanudado (resume code {}).", resume_code);

    // Liberar handles para evitar fugas.
    unsafe {
        CloseHandle(proc_info.hThread);
        CloseHandle(proc_info.hProcess);
    }

    Ok(())
}
